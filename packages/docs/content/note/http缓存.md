---
title: HTTP缓存
tags: http cache
---

## 什么是`web`缓存

`web`缓存主要指的是两部分：`浏览器缓存`和`http缓存`。

- 浏览器缓存

  像 localStorage、sessionStorage、cookie 等，本文中不再细说。// TODO

- http 缓存

  当请求命中缓存时，如果本地有已缓存的副本，就可以从本地而不是服务器中提取这个文档。主要针对`http`、`css`、`img`等静态资源。

## 解决的问题以及缺点

缓存可以解决的问题：

- 减少不必要的网络传输，节约带宽
- 更快的加载页面
- 减少服务器负载，避免服务器过载情况发生

缺点：

- 占用内存

## 强制缓存

强制缓存，简称强缓存。如果浏览器判断请求的资源有效命中强缓存，则可以直接从内存中读取目标资源，无需与服务器做任何通讯。

### 基于`Expires`实现的强缓存

`Expires`字段的作用是，设定一个强缓存时间，在此时间范围内，则直接从内存（或磁盘）中读取资源并返回。

这里存在一个问题，客户端判断资源是否过期依赖的机制是：获取本地时间戳，再和先前请求中`Expires`中返回的时间进行比较。但有一个很严重的漏洞是：如果本地时间不准确，或者与服务器时间不同步，就会存在资源无法被缓存或者资源永远被缓存的情况。

综上，我们通常使用`cache-control`来**代替**`Expries`字段。但如果需要考虑向下兼容的话，我们还是需要使用`Expries`字段。

### 基于`Cache-Control`实现的强缓存

`cache-control`在`HTTP 1.1`中被增加，使用很简单，只需在请求资源的返回头里设置需要缓存多久就好了，单位是秒。后续请求时若仍在缓存器内，则直接从磁盘或内存中读取，不会与服务器做任何交互。

使用这种方案，客户端会在接收到请求的时候开始倒计时，倒计时的时间就是`cache-contron`中设置的值，所以不存在客户端与服务器时间不一致的问题。

`cache-control`有六个属性：

- `max-age` 决定客户端资源缓存时间，单位为秒
- `s-maxage` 决定代理服务器缓存的时长，必须与`public`同时使用
- `no-cache` 表示强制进行协商缓存，与`no-store`互斥，不能同时出现
- `no-store` 表示禁止任何缓存策略，与`no-cache`互斥，不能同时出现
- `public` 表示资源既可以被客户端缓存，也可以被代理服务器缓存，与`private`互斥，不能同时出现
- `private` 表示资源只能被浏览器缓存，与`public`互斥，不能同时出现（默认表现）

如果需要多个属性同时设置时，使用`,`分割，示例如下：

> Cache-Control: max-age=3600,s-maxage=3600,public

## 协商缓存

### 基于`last-modified`实现的协商缓存

基于`last-modified`实现协商缓存的步骤为：

1. 服务器端读出资源的修改时间
2. 将读取的修改时间赋值给响应头中的`last-modified`字段
3. 设置响应头`cache-control`的值为`no-cache`

浏览器读取到`last-modified`字段后，会在后续的每一个相同请求中附加一个请求头`If-Modified-Since`，而这个请求头的值，即为上述第一个步骤读取出来的时间，服务端会通过比对资源的最新修改时间来决定使用缓存还是返回新的资源。

但是这种机制也存在两个非常明显的漏洞：

- 某些文件操作，并不会修改文件内容，但会修改文件修改时间。比如修改文件名后再改回原名，文件内容没有变化，但是缓存却失效了。

- 文件修改最小单位为秒，由此带来一个问题，如果在同一秒内完成了修改操作，虽然完成了修改操作，但是缓存却不会失效。

综上，`HTTP 1.1`新增了一个头信息`ETag`，作为`last-modified`的补充。

### 基于`ETag`实现的协商缓存

`ETag`与`last-modified`非常类似，只是将时间戳改为了文件指纹。具体流程如下：

1. 客户端第一次请求某资源时，服务端读取文件并计算出文件指纹，将文件指纹放在响应头`etag`中返回给客户端。
2. 第二次请求该资源时，客户端自动从缓存中读取出上次请求响应头中的`etag`值，赋值给请求头`if-None-Match`，让文件指纹跟随请求一起回到服务的。
3. 服务端拿到请求头中`if-None-Match`的文件指纹，再次读取资源并生成新的文件指纹，通过对两个文件指纹进行比对，判断资源是否发生更改。若没有更改直接返回`304`状态码和一个空的响应体，否则需要将新的文件指纹重新赋值给响应头中的`ETag`并随资源一并返回到客户端。

`ETag`的缺点：

- 服务端需要更多的计算开销。文件尺寸过大、频繁的重复计算等操作会严重影响服务器的性能。
- `ETag`有强验证和弱验证。强验证会深入到资源中每个字节，哪怕只有一个字节发生改变，都会生成不同的哈希值，它可以保证文件内容绝对的不变，但是非常的消耗计算值。弱验证是提取文件的部分属性来生成哈希值，因为不必精确到每个字节，所以整体速度比强验证快，但是准确率不高，会降低协商缓存的有效性。

综上，`ETag`并不能完全代替`last-modified`，仅仅只是作为一种补充方案。

## 如何使用

其实对于前端同学来说，我们什么都不需要干，哈哈哈。

后端同学的话，需要给对应的请求添加特定响应头，并在每次请求中进行新旧值的比对判断。

## 使用场景

一些静态资源，如 css 文件、js 文件、image 文件等。

一般使用`webpack`等现代构建工具生成的静态文件，都会在文件名中包含`hash`值，每次重新构建，`hash`值都会发生变化，文件名一直变化，非常适合强缓存。一些名称固定的文件，就需要进行协商缓存了。具体情况需要具体分析。

## 参考链接

- [中高级前端工程师都需要熟悉的技能--前端缓存](https://mp.weixin.qq.com/s/Y62Kv_WaTyTfXtuhA7cl8w)
